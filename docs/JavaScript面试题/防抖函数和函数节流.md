## 问题引入

 **问题1**:如果实现了dom拖拽功能，但是在绑定拖拽事件的时候发现每当元素稍微移动一点便触发了大量的回调函数，导致浏览器直接卡死，这个时候怎么办？

**问题2**：如果给一个按钮绑定了表单提交的post事件，但是用户有些时候在网络情况极差的情况下多次点击按钮造成表单重复提交，如何防止多次提交的发生？

## 函数防抖(debounce)

**概念：** 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

假设，我们观察的总时间为10秒钟，规定`1秒`作为一次事件的最小间隔时间。

如果触发事件的频率是 `0.5s/次`，那么因为始终没法等一秒钟就被再次触发了，所以最终没有一次事件是成功的。

当第一个函数开始执行，执行周期为`1s`，在第一个函数执行过程中，第二个函数执行了(在`0.5s`时)，第一次函数失败，重新开始计时，在第二个函数执行过程中第三个函数执行(`1s`时)，第二个函数失败重新开始计时······，一直到`10s`期间没有一个函数"挺过"`1s`所以没有函数执行成功。

## 函数节流(throttle)

**概念：** 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。

因为控制了最多一秒一次，频率为`0.5s/次`，所以每一秒钟就有一次事件作废。最终控制成`1s/次`

分析一下，这里我们的单位事件时`1s`也就是说在这个单位事件内无论有多少个函数只执行成功一个。所以在第一个函数执行的过程中，第二个函数执行，但是在单位事件内只有一个函数执行，所以第二个函数作废，`1s`后第一个函数执行完成，第三个函数执行，第四个函数作废······

## 应用场景

对于函数防抖，有以下几种应用场景：

- 给按钮加函数防抖防止表单多次提交。
- 对于输入框连续输入进行AJAX验证时，用函数防抖能有效减少请求次数。
- 判断`scroll`是否滑到底部，`滚动事件`+`函数防抖`

> 总的来说，适合多次事件**一次响应**的情况

对于函数节流，有如下几个场景：

- 游戏中的刷新率
- DOM元素拖拽
- Canvas画笔功能

>  总的来说，适合**大量事件**按时间做**平均**分配触发。

## 代码实现

### 防抖函数

```javascript
function debounce(fn, wait) {
  let timer = null;
  return function () {
    let context = this;   //储存调用debounce的环境
    let args = arguments;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(function () {
      fn.apply(context, args);    //绑定debounce环境和args参数
    }, wait);
  };
}
```

### 节流函数

```javascript
function throttle(fn, delay) {
    var timer;
    return function () {
        var _this = this;
        var args = arguments;
        if (timer) {
            return;
        }
        timer = setTimeout(function () {
            fn.apply(_this, args);
            timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器
        }, delay)
    }
}
```

